## Student Name:MHD-Oubai Al-khimi
## Student ID: 219533637

Prompt 1: "I’m starting A Lab. I need to build a meeting scheduler that suggests slots. I know the work day is 09:00 to 17:00 and we move in 15-minute chunks. Can you give me some boilerplate code? I'm thinking of using minutes for the math so I don't have to deal with string slicing. """
Stub file for the meeting slot suggestion exercise.

Implement the function `suggest_slots` to return a list of valid meeting start times
on a given day, taking into account working hours, and possible specific constraints. See the lab handout
for full requirements.
"""
from typing import List, Dict

def suggest_slots(
    events: List[Dict[str, str]],
    meeting_duration: int,
    day: str
) -> List[str]:
    """
    Suggest possible meeting start times for a given day.

    Args:
        events: List of dicts with keys {"start": "HH:MM", "end": "HH:MM"}
        meeting_duration: Desired meeting length in minutes
        day: Three-letter day abbreviation (e.g., "Mon", "Tue", ... "Fri")

    Returns:
        List of valid start times as "HH:MM" sorted ascending
    """
    # TODO: Implement this function
    raise NotImplementedError("suggest_slots function has not been implemented yet")" 



LLM Response 1: "That’s a smart move. Converting 'HH:MM' to an integer (minutes from midnight) makes the comparisons much easier. Here is a basic skeleton to get you started. I’ve included the conversion helpers so you can focus on the logic."
Python

def suggest_slots(events, meeting_duration, day):
    # Constants
    WORK_START = 540  # 09:00
    WORK_END = 1020   # 17:00
    
    def time_to_minutes(t_str):
        h, m = map(int, t_str.split(':'))
        return h * 60 + m

    def minutes_to_time(m):
        return f"{m//60:02d}:{m%60:02d}"

    # TODO: Implement the loop and event checking logic here
    valid_slots = []
    return valid_slots


User: "Okay, I took your boilerplate and tried to write the loop. I added the lunch break manually because that's a requirement, and I’m trying to check if the current time overlaps with an event. But it's not working right—it's suggesting slots that start during a meeting. Here is what I have so far:"
Python

    # My current attempt at the loop
    current_time = WORK_START
    while current_time + meeting_duration <= WORK_END:
        # I'm stuck here. How do I check all events at once 
        # without writing a million if-statements?
        for event in events:
            if current_time >= time_to_minutes(event['start']):
                # This logic is definitely wrong...
                pass 
        current_time += 15

LLM Response 2: "You're on the right track with the while loop! The reason it feels messy is that we're checking events one by one inside the loop.

Our fix: Let's consolidate everything. We can create a list called blocked_intervals. We'll put the lunch break (12:00–13:00) in there as a default, then add all the events from the input. Then, for every 15-minute slot, we just ask: 'Does this slot overlap with ANY interval in my blocked list?'"
Prompt 3: The "Aha!" Moment and Debugging

User: "I implemented the overlap check using any(). However, I just ran the tests I wrote, and test_unsorted_events_are_handled is failing. It’s giving me 10:00 when it should be 10:15.

Also, I added 5 more test cases like we talked about to handle the end-of-day edge cases. Here is the failure and the code I have now. I think I'm missing a step."
Plaintext

FAILED tests/test_solution.py::test_unsorted_events_are_handled - AssertionError: assert '10:00' == '10:15'

LLM Response 3: "I see exactly what's happening! Because the events in that test are out of order (13:00 comes before 09:30), the gap calculation is getting skipped or overwritten.

We just need to sort the blocked_intervals list before we start the loop. Since you've already handled the 15-minute increments and the duration check, adding a simple .sort() will align the meetings chronologically and fix that test error.

Here is our final refined version incorporating your test cases and that sorting fix:"
Python

def suggest_slots(events, meeting_duration, day):
    WORK_START, WORK_END = 540, 1020
    LUNCH = (720, 780) # 12:00 to 13:00
    
    def time_to_min(t):
        h, m = map(int, t.split(':'))
        return h * 60 + m

    def min_to_time(m):
        return f"{m//60:02d}:{m%60:02d}"

    # Building the list together
    blocked = [LUNCH]
    for e in events:
        blocked.append((time_to_min(e['start']), time_to_min(e['end'])))
    
    # The crucial fix we found:
    blocked.sort()

    valid_slots = []
    curr = WORK_START
    while curr + meeting_duration <= WORK_END:
        # Check overlap: slot starts before block ends AND slot ends after block starts
        if not any(curr < b_end and (curr + meeting_duration) > b_start for b_start, b_end in blocked):
            valid_slots.append(min_to_time(curr))
        curr += 15
        
    return valid_slots
